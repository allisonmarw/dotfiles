#!/bin/bash -x

# https://tools.ietf.org/html/rfc3986
# $$URL$$ The complete url
# schema://someone@
# ssh://aping1@new:2222/plex.apt-miss.com/a/b/?a=b&c=1#foo
# schema=ssh
# fullepath=aping1@new:2222
# user=aping1
# host=new
# port=2222
# params='a=b&c=1'
# anchor=foo
# requestpath=plex.apt-miss.com/a/b/

# ^((?<schema>[^:/?#]+):)?([/]{2}?(?<fullpath>(([^:/?#]+)@)?(?<host>[^:/?#]+)(:(?<port>[0-9]+))?))?(\/(?<requestpath>[^?#]*))(\?(?<params>[^#]*))?(#(?<anchor>.*))?


# readonly URI_REGEX='^(([^:/?#]+):)?(//{0,1}+((([^:/?#[:alphanum:]]+)@)?([^:/?#]+)(:([0-9]+))?))?(/([^?#]*))(\?([^#]*))?(#(.*))?'
#                    ↑↑          ↑      ↑↑↑             ↑        ↑↑           ↑ ↑        ↑  ↑        ↑ ↑
#                    |2 scheme     |       ||6 userinfo        7 host    | 9 port       | 11 rpath |  13 query | 15 fragment 1 scheme:     |  |5 userinfo@             8 :…           10 path    12 ?…       14 #…
#                                  |        4 authority
#                                  3 //…

readonly URI_REGEX='^((?<schema>[^:/?#]+):)?([/]{2}?(?<fullpath>(([^:/?#]+)@)?(?<host>[^:/?#]+)(:(?<port>[0-9]+))?))?(\/(?<requestpath>[^?#]*))(\?(?<params>[^#]*))?(#(?<anchor>.*))?'
# readonly URI_REGEX='^(([^:/?#]+):)?(/((([^:/?#]+)@)?([^:/?#]+)(:([0-9]+))?))?(/([^?#]*))(\?([^#]*))?(#(.*))?'
#                    ↑↑            ↑  ↑↑↑            ↑         ↑ ↑            ↑ ↑        ↑  ↑        ↑ ↑
#                    |2 scheme     |  ||6 userinfo   7 host    | 9 port       | 11 rpath |  13 query | 15 fragment 1 scheme:     |  |5 userinfo@             8 :…           10 path    12 ?…       14 #…
#                                  |  4 authority
#                                  3 //…
function uri2json() {
    set -a
    local _URI_SCHEMA _URI_ABS_URI_PATH _URI_AUTHORITY _URI_USER _URI_HOST _URI_PORT _URI_PATH _URI_RPATH _URI_QUERY _URI_FRAGMENT  
    printf -- '%s %s' "$*" "${URI_REGEX}"
    if [[ "$*" =~ ${URI_REGEX} ]]; then 
        if [[ ${#match[@]} -gt 0 ]]; then
            for i in {0..${#match[@]}}; do
                echo "${i} ${match[i]}"
            done
            # read -r _URI_MATCH <<< "${match[*]}"
            read -r _URI_SCHEMA _URI_ABS_URI_PATH _URI_AUTHORITY _URI_REMAINING "$([[ ${match[11]} =~ '@' ]] && echo -n _URI_USER)" _URI_HOST _URI_PORT _URI_PATH _URI_RPATH _URI_QUERY _URI_FRAGMENT <<< "${match[@]}"
            export _URI_SCHEMA _URI_ABS_URI_PATH _URI_AUTHORITY _URI_REMAINING _URI_USER _URI_HOST _URI_PORT _URI_PATH _URI_RPATH _URI_QUERY _URI_FRAGMENT
            python3 -c 'import json, os, sys;print(sys.stderr,json.dumps({str(k[5:]): v for k, v in os.environ.items() if k.startswith("_URI_") or k == "match"}))'
            return 0
        fi 
    fi
    printf -- 'Invalid URL\n' >&2
    set +a
}


parse_scheme () {
    [[ "$*" =~ $URI_REGEX ]] && echo "${BASH_REMATCH[2]}"
}

parse_abs_path() {
    # hier-part   = "//" authority path-abempty
    [[ "$*" =~ $URI_REGEX ]] && echo "${BASH_REMATCH[3]}"
}

parse_authority () {
    [[ "$*" =~ $URI_REGEX ]] && echo "${BASH_REMATCH[4]}"
}

parse_user () {
    [[ "$*" =~ $URI_REGEX ]] && echo "${BASH_REMATCH[6]}"
}

parse_host () {
    [[ "$*" =~ $URI_REGEX ]] && echo "${BASH_REMATCH[7]}"
}

parse_port () {
    [[ "$*" =~ $URI_REGEX ]] && echo "${BASH_REMATCH[9]}"
}

parse_path () {
    [[ "$*" =~ $URI_REGEX ]] && echo "${BASH_REMATCH[10]}"
}

parse_rpath () {
    # URI         = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
    # hier-part   = "//" authority path-abempty
    #             / path-absolute
    #             / path-rootless
    #             / path-empty
    [[ "$*" =~ $URI_REGEX ]] && echo "${BASH_REMATCH[11]}"
}

parse_query () {
    # URI         = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
    # hier-part   = "//" authority path-abempty
    #             / path-absolute
    #             / path-rootless
    #             / path-empty
    [[ "$*" =~ $URI_REGEX ]] && echo "${BASH_REMATCH[13]}"
}

parse_fragment () {
    # URI         = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
    # hier-part   = "//" authority path-abempty
    #             / path-absolute
    #             / path-rootless
    #             / path-empty

    [[ "$*" =~ $URI_REGEX ]] && echo "${BASH_REMATCH[15]}"
}

# $$HOST$$ The host portion of a url like scheme://host/
# $$USER$$ The username portion of a url like scheme://user@host/
# $$PASSWORD$$ The password portion of a url like scheme://user:password@host/
# $$PORT$$ The port number of a url like scheme://host:port/
# $$PATH$$ The path portion of a url like scheme://host/path
# $$RES$$ The portion of a url following the scheme.
# export THIS_PID="$$"
# CONTROL_PATH_TEMPLATE='~/.ssh/controlmasters/%r@%h:%p'"${THIS_PID}"'.sock'
# trap 'exit_sessions -a' HUP 
# trap exit_sessions EXIT 

if [[ ${1} ]]; then 
    [[ -d "${HOME}/.ssh/controlmasters" ]] || mkdir -q "${HOME}/.ssh/controlmasters"  || exit 1 
    _ABS_PATH="$(parse_abs_path "${1}")" # $$PATH$$
    _RPATH="$(parse_rpath "${1}")" # $$PATH$$
    _HOST_URL="$(parse_authority "${1}")"
    _ANCHOR="$(parse_fragment "${1}")"
    _QUERY="$(parse_query "${1}")"
    _REQPATH="$(parse_rpath "${1}")"
    # ssh://new/#?=plex.aptmiss.com

    uri2json "${1}"
    sleep 5
    shift
    if [[ ${_ANCHOR} =~ ^(-h\|new\|check\|forward\|exit\|stop\|cancel)$ &&${_ROOT} ]]; then
        case ${_ANCHOR} in 
            '-h')
            exec man ssh 
            ;; 
            'exit')
                if ssh -oControlMaster=auto \
                    -oControlPath="${HOME}/.ssh/controlmasters/%C" -oControlPersist=10m \
                    -O check "{_HOST_URL}" 2>&1 >/dev/null ; then
                    if ! ssh -oControlMaster=auto \
                        -oControlPath="${HOME}/.ssh/controlmasters/%C" -oControlPersist=10m \
                        -O exit "${_HOST_URL}" ; then
                        { ret=$?; printf -- 'unable to exit session @ %s' "${CONTROL_PATH_TEMPLATE}"; return 1; }
                    fi
                fi
            ;;
            'new')
                if ssh -oControlMaster=auto -oControlPath="${HOME}/.ssh/controlmasters/%C" -O check "${_HOST_URL}"; then
                    ssh -oControlMaster=auto -oControlPath="${HOME}/.ssh/controlmasters/%C" -O exit "${_HOST_URL}" 
                fi 
                exec ssh -oControlMaster=auto \
                    -oControlPath="${HOME}/.ssh/controlmasters/%C" -oControlPersist=10m \
                    "$_HOST_URL"
                ;;
            *)
                if [[ ! ${_HOST_URL} && ${_ROOT} == "${_PATH}" ]]; then
                    printf -- 'sshing to %s' "${_ROOT}"
                    ssh -t "${_ROOT}" -- "${@}"
                fi
                exit 11;
                ;;

            esac
fi


fi
