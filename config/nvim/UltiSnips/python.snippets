
snippet clicko "click.option decorator" b
@click.option("-$2")
endsnippet

snippet flaskunittest
import os
import tempfile

import pytest

from flask import flask


@pytest.fixture
def client():
    db_fd, flask.app.config['$1'] = tempfile.mkstemp()
    flask.app.config['$2'] = True

    with flask.app.test_client() as client:
        with flask.app.app_context():
            flask.init_db()
        yield client

    os.close(db_fd)
    os.unlink(flask.app.config['$1'])
endsnippet

snippet _unittest
import ${0:VISUAL}
import unittest

class TestAdd(unittest.TestCase):
    """
    Test the add function from the $0 library
    """

    def test_$1(self):
        """
        Test $1
        """
		$2

if __name__ == '__main__':
    unittest.main()
endsnippet


snippet simple_clicksetuptools
from setuptools import setup

# NOTE: you can use the _python_setup snippet for a more robust example
setup(
    name="${1:name}",
    version='0.1',
    py_modules=['${3:${1/\w+/\L$1\E/}}'],
    install_requires=[
        'Click',
    ],
    entry_points='''
        [console_scripts]
        ${2/[[:graph:]]+/\L$1\E/}=${4/\w+/\u$3/}:cli
    ''',
)
endsnippet

snippet clickgroup "Click CLI template" b
import click_completion
import click_completion.core
click_completion.init()


def completions(ctx, args, incomplete):
    pass


@click.group(
    name="${3:`!v expand("%:t:r")`}",
    subcommand_metavar="COMMAND <args>",
    options_metavar="<options>",
    context_settings=dict(max_content_width=85, help_option_names=["-h", "--help"]),
)
@click.version_option(
    version=__version__,
    prog_name="$3",
    message="[%(prog)s] Version %(version)s",
    help=f"Usage: v{__version__}.",
)
@click.option(
    "--filename",
    "-f",
    type=click.STRING,
	default='-',
    autocompletion=completions(),
    help="Filename you would like to load"
)
@click.option("--verbose", "-v", is_flag=True, help="Print verbose messages.")
@click.pass_context
def cli(ctx, filename, verbose):
    ctx.obj.filename = filename
    ctx.obj.verbose = verbose

@click.command()
${2:clicko
}@click.option('--verbose', is_flag=True, help="Will print verbose messages.")
def cli(ctx, ${1:${VISUAL}} verbose):
    """cli for $3"""
    ${5:pass
    }

if __name__ == "__main__":
    class ${6:ConfigContext}:
        def __init__(self):
            """things you want to inherit"""
            self.filename = None
            self.verbose = None

    cli(obj=${6}())
endsnippet

global !p
def create_row_placeholders(snip):
    # retrieving single line from current string and treat it like tabstops
    # count
    placeholders_amount = int(snip.buffer[snip.line].strip())

    # erase current line
    snip.buffer[snip.line] = ''

    # create anonymous snippet with expected content and number of tabstops
    anon_snippet_body =  '& '.join(['$' + str(i+1)
                                    for i in range(placeholders_amount)])

    # expand anonymous snippet
    snip.expand_anon(anon_snippet_body)
endglobal

post_jump "create_row_placeholders(snip)"
snippet "tr(\d+)" "latex table row variable" br
`!p snip.rv = match.group(1)`

endsnippet

snippet _click_command "Single command Click CLI template" b
import click
${4:
}
__version__ = "0.1"
@click.command()
${2:
}@click.option('--verbose', is_flag=True, help="Will print verbose messages.")
def cli(ctx, 
	${5:${VISUAL:pass}}


${1:${VISUAL}} verbose):
    """Click cli for ${3:myprogram}"""
    ${5:if verbose:
        click.echo("We are in the verbose mode.")
    click.echo("Hello World")}


if __name__ == "__main__":
	cli()
endsnippet

snippet  _clickunittest "Unittest for click cli" b
import click
from click.testing import CliRunner
from prompt import prompt
import unittest

def test_anythin():
  runner = CliRunner()
  result = runner.invoke(cli, ['--debug', 'sync'])
  assert result.exit_code == 0
  assert 'Debug mode is on' in result.output
  assert 'Syncing' in result.output

def test_stdout():
   runner = CliRunner()
   with runner.isolated_filesystem():
      with open('hello.txt', 'w') as f:
          f.write('Hello World!')

      result = runner.invoke(cat, ['hello.txt'])
      assert result.exit_code == 0
      assert result.output == 'Hello World!\n'

def test_prompts():
   """ Test input->output """ 
   runner = CliRunner()
   result = runner.invoke(prompt, input='wau wau\n')
   assert not result.exception
   assert result.output == 'Foo: wau wau\nfoo=wau wau\n'

if __name__ == "__main__":
    unittest.main()
endsnippet

snippet _python_setup "Setup.py minimal ish" b
# #!/usr/bin/python
# `!v expand("%:t:r")`
# Template from
# https://hynek.me/articles/sharing-your-labor-of-love-pypi-quick-and-dirty/
# Click integration from https://click.palletsprojects.com/en/7.x/setuptools/ 
import codecs
import os
import re

from setuptools import setup, find_packages


###################################################################

NAME = "attrs"
PACKAGES = find_packages(where="src")
META_PATH = os.path.join("src", "attr", "__init__.py")
KEYWORDS = ["class", "attribute", "boilerplate"]
CLASSIFIERS = [
    "Development Status :: 5 - Production/Stable",
    "Intended Audience :: Developers",
    "Natural Language :: English",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
    "Programming Language :: Python",
    "Programming Language :: Python :: 2",
    "Programming Language :: Python :: 2.7",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.4",
    "Programming Language :: Python :: 3.5",
    "Programming Language :: Python :: 3.6",
    "Programming Language :: Python :: 3.7",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
    "Topic :: Software Development :: Libraries :: Python Modules",
]
# TODO: Open requirements.txt..."
INSTALL_REQUIRES = ['click']

###################################################################

HERE = os.path.abspath(os.path.dirname(__file__))


def read(*parts):
    """
    Build an absolute path from *parts* and and return the contents of the
    resulting file.  Assume UTF-8 encoding.
    """
    with codecs.open(os.path.join(HERE, *parts), "rb", "utf-8") as f:
        return f.read()


META_FILE = read(META_PATH)


def find_meta(meta):
    """
    Extract __*meta*__ from META_FILE.
    """
    meta_match = re.search(
        r"^__{meta}__ = ['\"]([^'\"]*)['\"]".format(meta=meta),
        META_FILE, re.M
    )
    if meta_match:
        return meta_match.group(1)
    raise RuntimeError("Unable to find __{meta}__ string.".format(meta=meta))


if __name__ == "__main__":
    setup(
        name="${1:MyApp}",
        description=find_meta("description"),
        use_scm_version=True,
        setup_requires=['setuptools_scm'],
        license=find_meta("license"),
        url=find_meta("uri"),
        version=find_meta("version"),
        author=find_meta("author"),
        author_email=find_meta("email"),
        maintainer=find_meta("author"),
        maintainer_email=find_meta("email"),
        keywords=KEYWORDS,
        long_description=read("README.rst"),
        long_description_content_type="text/x-rst",
        packages=PACKAGES,
        package_dir={"": "src"},
        zip_safe=False,
        classifiers=CLASSIFIERS,
        install_requires=INSTALL_REQUIRES,
        entry_points='''
            [console_scripts]
            ${2:$1}=$3:cli
        ''',
        options={"bdist_wheel": {"universal": "1"}},
    )
endsnippet

